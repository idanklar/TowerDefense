// Represents an enemy
class Enemy {
    field int x, y;
    field int prevX, prevY;
    field int hp, maxHp;
    field boolean alive;
    field boolean escaped;
    field int pathIndex;

    // Constructor
    constructor Enemy new() {
        let x = 0;
        let y = 0;
        let prevX = 0;
        let prevY = 0;
        let hp = 0;
        let maxHp = 0;
        let alive = false;
        let pathIndex = 0;
        return this;
    }

    // Resets the enemy
    method void reset(int startX, int startY, int startHp) {
        let x = startX;
        let y = startY;
        let prevX = startX;
        let prevY = startY;
        let hp = startHp;
        let maxHp = startHp;
        let alive = true;
        let escaped = false;
        let pathIndex = 0;
        return;
    }

    // Moves the enemy
    method void step(Array pathX, Array pathY, int pathLen) {
        if (~alive) { return; }

        let prevX = x;
        let prevY = y;

        let pathIndex = pathIndex + 1;
        if (pathIndex < pathLen) {
            let x = pathX[pathIndex];
            let y = pathY[pathIndex];
        } else {
            // Reached end: count as "escaped" -> kill it
            let alive = false;
            let escaped = true;
        }
        return;
    }

    // Draws the enemy
    method void draw() {
        var int memAddress;
        var int barWidth;
        var int px, py;
        
        if (~alive) { return; }

        let memAddress = 16384 + (y * 512) + x;
        
        // Skeleton Sprite (Rows 0-13)
        // Row 15 reserved for HP Bar
        
        do Memory.poke(memAddress+0, -1);          // 1111111111111111 (Black bg)
        do Memory.poke(memAddress+32, -4089);      // 1111000000000111 (Head top)
        do Memory.poke(memAddress+64, -4089);      // 1111000000000111
        do Memory.poke(memAddress+96, -4089);      // 1111000000000111
        do Memory.poke(memAddress+128, -1);        // Neck
        do Memory.poke(memAddress+160, -8185);     // 1110000000000111 (Shoulders)
        do Memory.poke(memAddress+192, -8185);     // Ribs
        do Memory.poke(memAddress+224, -8185);     
        do Memory.poke(memAddress+256, -8185);     
        do Memory.poke(memAddress+288, -1);        // Waist
        do Memory.poke(memAddress+320, -13101);    // 1100110011001111 (Hips/Legs)
        do Memory.poke(memAddress+352, -13101);    
        do Memory.poke(memAddress+384, -13101);    
        do Memory.poke(memAddress+416, -13101);    
        do Memory.poke(memAddress+448, -1);        // Spacer (Black)
        do Memory.poke(memAddress+480, -1);        // BG for Bar (Black)
        
        // Draw HP Bar (White on Black)
        if (maxHp > 0) {
            let barWidth = (hp * 16) / maxHp;
            if (barWidth > 0) {
                // Ensure length is clamped
                if (barWidth > 16) { let barWidth = 16; }
                
                let px = x * 16;
                let py = y * 16;
                
                do Screen.setColor(false); // White
                do Screen.drawRectangle(px, py + 15, px + barWidth - 1, py + 15);
            }
        }
        
        return;
    }

    // Erases the enemy
    method void erase(boolean prevOnPath) {
        var int px, py;

        // FIX: Erase the CURRENT position (x,y), not prevX/prevY.
        // Because we erase BEFORE stepping, and 'x' is where we are currently drawn.
        let px = x * 16;
        let py = y * 16;

        // Ensure we always paint BLACK because enemies are restricted to the path.
        do Screen.setColor(true);
        do Screen.drawRectangle(px, py, px + 15, py + 15);

        return;
    }


    // Takes damage
    method void takeDamage(int d) {
        if (~alive) { return; }
        let hp = hp - d;

        if (hp < 1) {
            let alive = false;
        }
        return;
    }

    method boolean isAlive() { return alive; }
    method boolean hasEscaped() { return escaped; }
    method int getX() { return x; }
    method int getY() { return y; }
    method int getPrevX() { return prevX; }
    method int getPrevY() { return prevY; }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}
