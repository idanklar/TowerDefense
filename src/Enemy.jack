// Enemy: moves along a predefined path and can take damage until it dies.
class Enemy {
    field int x, y;
    field int prevX, prevY;
    field int hp, maxHp;
    field boolean alive;
    field boolean escaped;
    field int pathIndex;

    // Creates an enemy (inactive until reset()).
    constructor Enemy new() {
        let x = 0;
        let y = 0;
        let prevX = 0;
        let prevY = 0;
        let hp = 0;
        let maxHp = 0;
        let alive = false;
        let pathIndex = 0;
        return this;
    }

    // Spawns / respawns the enemy at the start of the path with given HP.
    method void reset(int startX, int startY, int startHp) {
        let x = startX;
        let y = startY;
        let prevX = startX;
        let prevY = startY;
        let hp = startHp;
        let maxHp = startHp;
        let alive = true;
        let escaped = false;
        let pathIndex = 0;
        return;
    }

    // Advances the enemy by one step along the path arrays.
    method void step(Array pathX, Array pathY, int pathLen) {
        if (~alive) { return; }

        let prevX = x;
        let prevY = y;

        let pathIndex = pathIndex + 1;
        if (pathIndex < pathLen) {
            let x = pathX[pathIndex];
            let y = pathY[pathIndex];
        } else {
            // Reached end: count as "escaped" -> kill it
            let alive = false;
            let escaped = true;
        }
        return;
    }

    // Draws the enemy as a Skeleton Sprite (White bones on Black path)
    method void draw() {
        var int memAddress;
        
        if (~alive) { return; }

        let memAddress = 16384 + (y * 512) + x;
        // Skeleton Bitmap (16x16)
        // Designed to be White (0) on Black (1) or vice versa.
        // Since we are on a BLACK path (color true), we want lines to be WHITE (color false).
        // Screen.setColor(true) draws black. Screen.setColor(false) draws white.
        // But Memory.poke sets the 16-bit word directly.
        // 1 = Black, 0 = White.
        // We want the path (around the skeleton) to be Black (1). The Skeleton to be White (0).
        // So we need a mask where 1s are background and 0s are bones.

        // Row 0-15
        do Memory.poke(memAddress+0, -1);          // 1111111111111111 (Black bg)
        do Memory.poke(memAddress+32, -4089);      // 1111000000000111 (Head top)
        do Memory.poke(memAddress+64, -4089);      // 1111000000000111
        do Memory.poke(memAddress+96, -4089);      // 1111000000000111
        do Memory.poke(memAddress+128, -1);        // Neck
        do Memory.poke(memAddress+160, -8185);     // 1110000000000111 (Shoulders)
        do Memory.poke(memAddress+192, -8185);     // Ribs
        do Memory.poke(memAddress+224, -8185);     
        do Memory.poke(memAddress+256, -8185);     
        do Memory.poke(memAddress+288, -1);        // Waist
        do Memory.poke(memAddress+320, -13101);    // 1100110011001111 (Hips/Legs)
        do Memory.poke(memAddress+352, -13101);    
        do Memory.poke(memAddress+384, -13101);    
        do Memory.poke(memAddress+416, -13101);    
        do Memory.poke(memAddress+448, -13101);    
        do Memory.poke(memAddress+480, -1);        
        
        // HP Bar is drawn separately in Game.jack now? No, HUD is general. 
        // We removed individual HP bars for sprite clarity, or we overlay them?
        // Let's implement a simple overlay line if needed, but for now just the sprite.
        return;
    }

    // Erases the enemy by restoring the background of the previous cell.
    method void erase(boolean prevOnPath) {
        var int px, py;

        // FIX: Erase the CURRENT position (x,y), not prevX/prevY.
        // Because we erase BEFORE stepping, and 'x' is where we are currently drawn.
        let px = x * 16;
        let py = y * 16;

        // Ensure we always paint BLACK because enemies are restricted to the path.
        do Screen.setColor(true);
        do Screen.drawRectangle(px, py, px + 15, py + 15);

        return;
    }


    // Applies damage; if hp drops below 1 -> dead.
    method void takeDamage(int d) {
        if (~alive) { return; }
        let hp = hp - d;

        if (hp < 1) {
            let alive = false;
        }
        return;
    }

    method boolean isAlive() { return alive; }
    method boolean hasEscaped() { return escaped; }
    method int getX() { return x; }
    method int getY() { return y; }
    method int getPrevX() { return prevX; }
    method int getPrevY() { return prevY; }

    method void dispose() {
        do Memory.deAlloc(this);
        return;
    }
}
