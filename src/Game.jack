// Main game class
class Game {
    field boolean running;
    field boolean inWave;
    field Cursor cursor;

    field Array towers;
    field int towerCount;

    field Array enemies;
    field int enemyCount;

    field Array pathX;
    field Array pathY;
    field int pathLen;

    field int spaceHeld;

    field int enemyTick;
    field int enemyDelay;

    field int wave;
    field int toSpawn;
    field int spawned;
    field int spawnTick; 
    field int killedCount; // Tracks how many killed/escaped in this wave so far
    field int spawnDelay;

    // String constants to prevent memory leaks in main loop
    field String sWave;
    field String sEnemies;
    field String sSpace;
    field String sMoney;
    field String sLives;
    field String sPressStart;

    field int money;
    field int lives;

    field boolean inWave;
    
    // Constructor
    constructor Game new() {
        let running = true;
        let inWave = false;

        let towers = Array.new(30);
        let towerCount = 0;

        let enemies = Array.new(4);
        let enemyCount = 0;

        // Create 4 enemy objects once
        let enemies[0] = Enemy.new();
        let enemies[1] = Enemy.new();
        let enemies[2] = Enemy.new();
        let enemies[3] = Enemy.new();

        let cursor = Cursor.new(2, 2);

        let pathX = Array.new(128);
        let pathY = Array.new(128);
        let pathLen = 0;

        let spaceHeld = 0;

        let enemyTick = 0;
        let enemyDelay = 6;

        let wave = 0;
        let toSpawn = 0;
        let spawned = 0;
        let spawnTick = 0;
        let spawnDelay = 20; // 2x (was 10)

        let sWave = "Wave: ";
        let sEnemies = "Enemies: ";
        let sSpace = "   ";
        let sMoney = "Coins: ";
        let sLives = "Lives: ";
        let sPressStart = "Press 's' to start Wave ";

        let money = 100;
        let lives = 20;

        do Screen.clearScreen();
        do Screen.clearScreen();
        // Path building moved to run() after selection
        
        return this;
    }

    // Main game loop
    method void run() {
        var int key;
        var int idx;
        var int mapChoice;

        let mapChoice = showStartScreen();
        do buildPath(mapChoice);
        do drawPath();
        do startNextWave();

        while (running) {
            let key = Keyboard.keyPressed();
            if (key = 113) { let running = false; } // q

            // --- ALWAYS ON LOGIC (Cursor, Building, HUD) ---

            // cursor
            do cursor.erase(isPathCell(cursor.getPrevX(), cursor.getPrevY()));
            do cursor.move(key);
            do cursor.draw();

            // space: place/remove tower (debounced)
            if (key = 32) {
                if (spaceHeld = 0) {
                    let spaceHeld = 1;

                    let idx = findTowerIndex(cursor.getX(), cursor.getY());
                    if (~(idx = -1)) {
                        do removeTowerAt(idx);
                    } else {
                        if (towerCount < 30) {
                            if (money > 49) {
                                if (~isPathCell(cursor.getX(), cursor.getY())) {
                                    let towers[towerCount] = Tower.new(cursor.getX(), cursor.getY());
                                    let towerCount = towerCount + 1;
                                    let money = money - 50;
                                }
                            }
                        }
                    }
                }
            } else {
                let spaceHeld = 0;
            }

            // Always draw HUD to show updated money/lives
            do drawHUD();
            do redrawTowers();

            // WAITING STATE: waiting for 's' to start wave
            if (~inWave) {
                do Output.moveCursor(2, 20); // Top center
                do Output.printString(sPressStart);
                do Output.printInt(wave);
                
                // Allow 'S' (83) or 's' (115)
                if ((key = 83) | (key = 115)) { 
                    let inWave = true;
                    // clear message cleanly
                    do Output.moveCursor(2, 20);
                    do Output.printString("                         "); 
                    do Output.printString("      "); // extra space just in case
                }
            } else {
                // PLAYING STATE: Combat logic

                // spawn logic
                do handleSpawning();

                // enemy movement timing
                let enemyTick = enemyTick + 1;
                if (~(enemyTick < enemyDelay)) {
                    let enemyTick = 0;
                    do stepEnemies();
                }

                // combat + draw
                do towersAttack();
                do drawEnemies();

                // Check Game Over
                if (lives < 1) {
                   do drawGameOver();
                   let running = false;
                }

                // wave progression
                if (isWaveCleared()) {
                    do startNextWave();
                }
            }

            do Sys.wait(25); // 2x Frame Rate (was 50)
        }

        return;
    }

    // Spawns enemies
    method void handleSpawning() {
        var int hp;
        var int i;
        var Enemy e;

        if (spawned = toSpawn) { return; }
        
        // Count active enemies to ensure we don't exceed 4
        // (Checking pool availability)

        let spawnTick = spawnTick + 1;
        if (spawnTick < spawnDelay) { return; }
        let spawnTick = 0;

        // Find a dead slot
        let i = 0;
        while (i < 4) {
            let e = enemies[i];
            if (~e.isAlive()) {
                // Found slot! Spawn here.
                let hp = 2 + wave;
                do e.reset(pathX[0], pathY[0], hp);
                let spawned = spawned + 1;
                
                // Force exit loop
                let i = 4; 
            }
            let i = i + 1;
        }

        return;
    }

    // Moves all enemies
    method void stepEnemies() {
        var int i;
        var Enemy e;

        let i = 0;
        while (i < 4) { // Always check all 4 slots
            let e = enemies[i];

            if (e.isAlive()) {
                do e.erase(isPathCell(e.getPrevX(), e.getPrevY()));
                do e.step(pathX, pathY, pathLen);

                // If it died by reaching the end, erase its current cell once
                if (~e.isAlive()) {
                    if (e.hasEscaped()) {
                        let lives = lives - 1;
                    }
                    let killedCount = killedCount + 1; // It's gone from the board
                    do e.erase(isPathCell(e.getX(), e.getY()));
                }
            }

            let i = i + 1;
        }

        return;
    }

    // Towers attack enemies
    method void towersAttack() {
        var int ti;
        var int ei;
        var Tower t;
        var Enemy e;

        let ti = 0;
        while (ti < towerCount) {
            let t = towers[ti];

            if (t.canShoot()) {
                let ei = 0;
                while (ei < 4) {
                    let e = enemies[ei];

                    if (e.isAlive()) {
                        if (t.inRange(e.getX(), e.getY())) {
                            do e.takeDamage(1);

                            // if it died now, erase it immediately
                            if (~e.isAlive()) {
                                do e.erase(isPathCell(e.getX(), e.getY()));
                                let money = money + 10;
                                let killedCount = killedCount + 1;
                            }

                            let ei = 4; // break inner loop
                        }
                    }

                    let ei = ei + 1;
                }
            }

            let ti = ti + 1;
        }

        return;
    }

    // Redraws all towers
    method void redrawTowers() {
        var int i;
        var Tower t;

        let i = 0;
        while (i < towerCount) {
            let t = towers[i];
            do t.draw();
            let i = i + 1;
        }
        return;
    }

    // Draws all enemies
    method void drawEnemies() {
        var int i;
        var Enemy e;

        let i = 0;
        while (i < 4) {
            let e = enemies[i];
            if (e.isAlive()) { do e.draw(); }
            let i = i + 1;
        }
        return;
    }

    // Checks if wave is done
    method boolean isWaveCleared() {
        if (~(spawned = toSpawn)) { return false; }
        if (killedCount < toSpawn) { return false; }
        return true;
    }

    // Starts the next wave
    method void startNextWave() {
        do clearEnemyMarks();

        let wave = wave + 1;
        let inWave = false; // Pause and wait for user

        // WIN condition: stop after 10 waves
        if (wave = 11) {
            do drawWinScreen();
            let running = false;
            return;
        }

        // up to 4 enemies per wave
    let toSpawn = 2 + wave; 
    // REMOVED CAP: if (toSpawn > 4) { let toSpawn = 4; }

    let spawned = 0;
    // enemyCount is no longer used as a "max index" 
    // We always iterate 0..3 and check isAlive
    
    let killedCount = 0;
    let enemyTick = 0;

    // speed up enemies slowly (min delay 4 -> formerly 2)
    // Old: 6 - (wave/2). New for 2x FPS + slower scaling:
    // Base 12 (very slow) -> reduced by wave
    let enemyDelay = 14 - wave; 
    if (enemyDelay < 4) { let enemyDelay = 4; }

    // spawn faster (min delay 8 -> formerly 4)
    let spawnDelay = 24 - wave;
    if (spawnDelay < 8) { let spawnDelay = 8; }

    return;
    }


    // Clears artifacts
    method void clearEnemyMarks() {
        do drawPath();
        do redrawTowers();
        return;
    }

    // Finds tower index
    method int findTowerIndex(int x, int y) {
        var int i;
        var Tower t;

        let i = 0;
        while (i < towerCount) {
            let t = towers[i];

            if ((t.getX() = x) & (t.getY() = y)) {
                return i;
            }

            let i = i + 1;
        }

        return -1;
    }

    // Removes tower
    method void removeTowerAt(int idx) {
        var int i;
        var Tower t;

        let t = towers[idx];

        do Screen.setColor(isPathCell(t.getX(), t.getY()));
        do drawCellRect(t.getX(), t.getY());

        do t.dispose();

        let money = money + 30; // Refund

        let i = idx;
        while (i < (towerCount - 1)) {
            let towers[i] = towers[i + 1];
            let i = i + 1;
        }

        let towerCount = towerCount - 1;
        return;
    }

    // Draws a cell
    method void drawCellRect(int gx, int gy) {
        var int px;
        var int py;

        let px = gx * 16;
        let py = gy * 16;
        do Screen.drawRectangle(px, py, px + 15, py + 15);
        return;
    }

    // Build map
    method void buildPath(int mapId) {
        var int x;
        var int y;

        let pathLen = 0;

        if (mapId = 1) {
            // MAP 1: Classic Winding
            // (0,9)->(14,9)
            let y = 9; let x = 0;
            while (x < 15) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
            // (14,9)->(14,4)
            let x = 14; let y = 8;
            while (y > 3) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let y=y-1; }
            // (14,4)->(23,4)
            let y = 4; let x = 15;
            while (x < 24) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
            // (23,4)->(23,9)
            let x = 23; let y = 5;
            while (y < 10) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let y=y+1; }
            // (23,9)->(31,9)
            let y = 9; let x = 24;
            while (x < 32) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
        }

        if (mapId = 2) {
            // MAP 2: ZigZag
            // (0,3)->(29,3) Right
            let y = 3; let x = 0;
            while (x < 30) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
            // (29,3)->(29,8) Down
            let x = 29; let y = 4;
            while (y < 9) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let y=y+1; }
            // (29,8)->(2,8) Left
            let y = 8; let x = 28;
            while (x > 1) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x-1; }
            // (2,8)->(2,13) Down
            let x = 2; let y = 9;
            while (y < 14) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let y=y+1; }
            // (2,13)->(31,13) Right
            let y = 13; let x = 3;
            while (x < 32) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
        }

        if (mapId = 3) {
            // MAP 3: The U-Turn
            // (0,3)->(28,3) Right
            let y = 3; let x = 0;
            while (x < 29) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x+1; }
            // (28,3)->(28,12) Down
            let x = 28; let y = 4;
            while (y < 13) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let y=y+1; }
            // (28,12)->(0,12) Left
            let y = 12; let x = 27;
            while (x > -1) { let pathX[pathLen]=x; let pathY[pathLen]=y; let pathLen=pathLen+1; let x=x-1; }
        }

        return;
    }

    // Draws the map
    method void drawPath() {
        var int i;

        do Screen.setColor(false);
        do Screen.clearScreen();

        do Screen.setColor(true);
        let i = 0;
        while (i < pathLen) {
            do drawCellRect(pathX[i], pathY[i]);
            let i = i + 1;
        }

        return;
    }

    // Checks if cell is on path
    method boolean isPathCell(int gx, int gy) {
        var int i;
        let i = 0;

        while (i < pathLen) {
            if ((pathX[i] = gx) & (pathY[i] = gy)) { return true; }
            let i = i + 1;
        }

        return false;
    }

    // Draws the HUD
    method void drawHUD() {
        do Output.moveCursor(0, 0);
        do Output.printString(sWave);
        do Output.printInt(wave);
        do Output.printString(sSpace);

        do Output.moveCursor(1, 0);
        do Output.printString(sEnemies);
        do Output.printInt(toSpawn - killedCount); // Show actual remaining
        do Output.printString(sSpace);

        do Output.moveCursor(0, 15);
        do Output.printString(sMoney);
        do Output.printInt(money);
        do Output.printString(sSpace);

        do Output.moveCursor(1, 15);
        do Output.printString(sLives);
        do Output.printInt(lives);
        do Output.printString(sSpace);

        return;
    }

    method void drawGameOver() {
        do Screen.clearScreen();
        do Output.moveCursor(10, 27);
        do Output.printString("GAME OVER");
        do Output.moveCursor(12, 25);
        do Output.printString("Reached Wave: ");
        do Output.printInt(wave);
        return;
    }

    // Show win screen
    method void drawWinScreen() {
        do Screen.clearScreen();
        do Output.moveCursor(8, 27);
        do Output.printString("YOU WIN!");
        
        do Output.moveCursor(10, 23);
        do Output.printString("CONGRATULATIONS!");
        
        do Output.moveCursor(12, 20);
        do Output.printString("You Defended the Path!");
        
        return;
    }

    // Select map
    method int showStartScreen() {
        var char key;
        var int selection;
        let selection = 0;

        do Screen.clearScreen();
        
        do Output.moveCursor(5, 25);
        do Output.printString("TOWER DEFENSE");
        
        do Output.moveCursor(8, 22);
        do Output.printString("Goal: Survive 10 Waves");
        
        do Output.moveCursor(10, 20);
        do Output.printString("Controls:");
        do Output.moveCursor(11, 22);
        do Output.printString("[Arrows] Move Cursor");
        do Output.moveCursor(12, 22);
        do Output.printString("[Space] Build/Sell (50c)");
        
        do Output.moveCursor(15, 20);
        do Output.printString("Select Map to Start:");
        do Output.moveCursor(17, 22);
        do Output.printString("[1] Classic");
        do Output.moveCursor(18, 22);
        do Output.printString("[2] The ZigZag");
        do Output.moveCursor(19, 22);
        do Output.printString("[3] The U-Turn");
        
        // Wait for 1, 2, or 3
        while (selection = 0) {
            let key = Keyboard.keyPressed();
            if (key = 49) { let selection = 1; } // 1
            if (key = 50) { let selection = 2; } // 2
            if (key = 51) { let selection = 3; } // 3
        }
        
        // Clear and redraw game
        do Screen.clearScreen();
        // Path will be drawn by caller
        return selection;
    }

    // Disposes the game
    method void dispose() {
        var int i;
        var Tower t;
        var Enemy e;

        let i = 0;
        while (i < towerCount) {
            let t = towers[i];
            do t.dispose();
            let i = i + 1;
        }

        let i = 0;
        while (i < 4) {
            let e = enemies[i];
            do e.dispose();
            let i = i + 1;
        }

        do cursor.dispose();
        
        do sWave.dispose();
        do sEnemies.dispose();
        do sSpace.dispose();
        do sMoney.dispose();
        do sLives.dispose();
        do sPressStart.dispose();

        do Memory.deAlloc(this);
        return;
    }
}
